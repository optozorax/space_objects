#pragma once

#include <spob/spob.h>
#include "spline.h"

namespace spob
{

	//-------------------------------------------------------------------------
	/// Вспомогательные функции
	double getSlopeAngle(const space2& crd);
	vec2 getOffset(const space2& crd);

	//-------------------------------------------------------------------------
	/// Линейная интерполяция двух чисел
	double interpolate(double a, double b, double pos);

	/// Линейная интерполяция между двумя векторами
	vec2 interpolate(const vec2& a, const vec2& b, double pos);

	/// Линейная интерполяция между двумя системами координат. Проблема: в процессе угол между системами координат не обязательно сохраняется. Например, если интерполируются две системы с углом между осями равным 90 градусов, то между ними угол может меняться. 
	crd2 interpolate(const crd2& a, const crd2& b, double pos);


	/// Линейная интерполяция двух углов по часовой и против часовой стрелки
	double interpolateCircularClockwise(double alpha, double beta, double pos);
	double interpolateCircularAntiClockwise(double alpha, double beta, double pos);


	/// Линейная интерполяция угла и радиуса между двумя векторами в полярных координатах. С жестко и не жестко заданным направлением интерполяции.
	vec2 interpolateCircular(const vec2& a, const vec2& b, double pos);
	vec2 interpolateCircularClockwise(const vec2& a, const vec2& b, double pos, double pos2 = -1);
	vec2 interpolateCircularAntiClockwise(const vec2& a, const vec2& b, double pos, double pos2 = -1);

	/// Позволяет рассчитать центр окружности по двум точкам, принадлежащим ей и радиусу. isFirst означает возвращать первую окружность или вторую (потому что таких может быть две).
	vec2 calcCircle(const vec2& p1, const vec2& p2, double r, bool isFirst);

	/// Интерполирует две системы координат при помощи окружности. Свойства: траектория эллиптическая; угол между системами координат сохраняется на протяжении всей интерполяции. Можно специально задать тип интерполяции: автоматический (0), по часовой стрелке (1), против часовой стрелки (2). Так же можно задать инвертирование выбора окружности для интерполяции. Недостаток этой интерполяции заключается в том, что производная в начале и в конце не соответствуют друг другу, то есть если это зациклить на анимации, то будет видна разная скорость, и не будет видно, как будто последний кадр идеально переходит в первый.
	crd2 interpolateCircular(const crd2& a, const crd2& b, double pos, double r = 5, int type = 0, bool isInvert = false);


	//-------------------------------------------------------------------------
	/** Интерполирует две системы координат на основе сплайнов. Сохраняет все положительные свойства предыдущих интерполяций, как, например сохранение угла между системами координат (если у обоих систем равный угол между осями). Так же обладает такой особенность, что итоговая интерполяция делает идеальный переход между t=1 и t=0, потому что сплайн для интерполяции подбирается таким образом, чтобы все производные вплоть до (n-1)-й степени были непрерывны и равны в точке стыка предыдущего и следующего кадра. Таким образом, если использовать этот класс, то можно получить идеально зацикленные анимации, где основная суть заключается в переходе из одной системы координат в другую.

	Так же здесь пока не реализована работа с системами координат, у которых различаются не только форма и масштаб. Да и не будет реализована, потому что есть следующий класс, где это уже работает автоматически. */
	class SplineInterpolator
	{
	public:
		SplineInterpolator(int n, const crd2& c1, const crd2& c2);

		crd2 interpolate(double pos) const;
	private:
		polynom_spline2_crd_interpolation spline;
		space2 start, end;
	};

	//-------------------------------------------------------------------------
	/** Интерполирует две системы координат на основе сплайнов. Отличается от предыдущей интерполяции тем, что нитерполирует не просто позицию системы координат, а сразу всю систему координат. */
	class SplineInterpolator2
	{
	public:
		SplineInterpolator2(int n, const crd2& c1, const crd2& c2);

		crd2 interpolate(double pos) const;
	private:
		polynom_spline2_crd_interpolation2 spline;
		space2 start, end;
	};

	//-------------------------------------------------------------------------
	/** Возводит матрицу в произвольную вещественную степень. */ 
	glm::mat3 pow(const glm::mat3& p, double n);

	/** Интерполирует две системы координат на основе возведения матрицы перехода к новым координатам в степень. Собирает в себя все положительные черты предыдущих подходов, а так же на практике показывается себя наилучшим образом. Интерполяция на основе сплайнов шатается для классического дерева Пифагора, а вот эта интерполяция - нет. */
	class MatrixPowerInterpolator
	{
	public:
		MatrixPowerInterpolator(const crd2& c1, const crd2& c2);

		crd2 interpolate(double pos) const;
	private:
		space2 start;
		glm::mat3 P;
	};

}